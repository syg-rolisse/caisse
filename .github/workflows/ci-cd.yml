# ===================================================================
#                PIPELINE CI/CD POUR LE PROJET CAISSE
# ===================================================================
# Workflow :
# 1. Push sur 'develop' -> Teste puis d√©ploie sur Staging.
# 2. Merge de PR vers 'main' -> Teste puis d√©ploie sur Production.
# ===================================================================

name: Caisse CI/CD Pipeline

on:
  push:
    branches:
      - develop
  pull_request:
    types: [closed]
    branches:
      - main

jobs:
  # ===================================================================
  #  JOB 1: Tester la configuration de Staging
  # ===================================================================
  test-and-build:
    name: üß™ Tester l'application (avec la config de Staging)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout du code
        uses: actions/checkout@v4

      - name: Cr√©er les fichiers .env pour les tests
        run: |
          echo "Cr√©ation des .env pour le backend et la BDD..."
          echo "${{ secrets.STAGING_ENV_APIS }}" > ./apis/.env
          echo "${{ secrets.STAGING_ENV_DB }}" > ./apis/.env.db
          
          # AJOUT : Cr√©ation du .env pour le frontend (apps)
          echo "Cr√©ation du .env pour le frontend..."
          echo "${{ secrets.STAGING_ENV_APPS }}" > ./apps/.env

      - name: Lancer Docker Compose pour les tests
        run: docker compose -f docker-compose.staging.yml up --build -d

      - name: V√©rifier l'√©tat des conteneurs
        run: |
          echo "Attente de 20s pour la stabilisation des services..."
          sleep 20
          docker compose -f docker-compose.staging.yml ps
          if [ $(docker compose -f docker-compose.staging.yml ps | grep -E "Up|running" | wc -l) -lt $(docker compose -f docker-compose.staging.yml ps -q | wc -l) ]; then
            echo "::error::Un ou plusieurs conteneurs n'ont pas d√©marr√© correctement."
            docker compose -f docker-compose.staging.yml logs
            exit 1
          fi
          echo "Tests d'int√©gration r√©ussis."

  # ===================================================================
  #  JOB 2: D√©ployer l'application sur Staging
  # ===================================================================
  deploy-staging:
    name: üöÄ D√©ployer sur Staging
    needs: test-and-build
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/develop'
    environment: staging
    steps:
      - name: Checkout du code
        uses: actions/checkout@v4

      - name: Copier les fichiers sur le VPS de Staging
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.VPS_IP }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.VPS_PORT }}
          source: "."
          target: "/opt/caisse-staging"
          rm: true

      - name: D√©ployer l'application sur Staging
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.VPS_IP }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.VPS_PORT }}
          script: |
            cd /opt/caisse-staging
            
            echo "Cr√©ation des fichiers .env pour l'environnement de staging..."
            echo "${{ secrets.STAGING_ENV_APIS }}" > ./apis/.env
            echo "${{ secrets.STAGING_ENV_DB }}" > ./apis/.env.db
            # AJOUT : Cr√©ation du .env pour le frontend (apps)
            echo "${{ secrets.STAGING_ENV_APPS }}" > ./apps/.env
            
            echo "Red√©marrage des services de staging..."
            docker compose -f docker-compose.staging.yml -p caisse_staging down || true
            docker compose -f docker-compose.staging.yml -p caisse_staging up --build -d
            
            echo "Nettoyage des anciennes images Docker..."
            docker image prune -f

  # ===================================================================
  #  JOB 3: D√©ployer l'application sur Production
  # ===================================================================
  deploy-production:
    name: üöÄ D√©ployer sur Production
    needs: test-and-build
    runs-on: ubuntu-latest
    if: github.event.pull_request.merged == true && github.ref == 'refs/heads/main'
    environment: production
    steps:
      - name: Checkout du code
        uses: actions/checkout@v4

      - name: Copier les fichiers sur le VPS de Production
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.VPS_IP }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.VPS_PORT }}
          source: "."
          target: "/opt/caisse-prod"
          rm: true

      - name: D√©ployer l'application sur Production
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.VPS_IP }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.VPS_PORT }}
          script: |
            cd /opt/caisse-prod
            
            echo "Cr√©ation des fichiers .env pour l'environnement de production..."
            echo "${{ secrets.PRODUCTION_ENV_APIS }}" > ./apis/.env
            echo "${{ secrets.PRODUCTION_ENV_DB }}" > ./apis/.env.db
            # AJOUT : Cr√©ation du .env pour le frontend (apps)
            echo "${{ secrets.PRODUCTION_ENV_APPS }}" > ./apps/.env
            
            echo "Red√©marrage des services de production..."
            docker compose -f docker-compose.prod.yml -p caisse_prod down || true
            docker compose -f docker-compose.prod.yml -p caisse_prod up --build -d
            
            echo "Nettoyage des anciennes images Docker..."
            docker image prune -f